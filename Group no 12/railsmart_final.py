# -*- coding: utf-8 -*-
"""RailSmart Final

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19KKBAtuEAvYFJRE0GAqkFGYjEw6WOCUw
"""

!sudo apt install tesseract-ocr
!sudo apt install libtesseract-dev

!pip install pytesseract

import pytesseract
from PIL import Image
import re

# Load image
image_path = "ticket1.png"
img = Image.open(image_path)

# Perform OCR we use pytesseract
text = pytesseract.image_to_string(img)

# Extract parameters using regex
def extract_ticket_info(text):
    info = {}

    # Regex patterns for each field
    patterns = {
        "Date of Issue": r"Date of Issue:\s*([\d/]+)",
        "Journey Type": r"Journey Type:\s*(\w+)",
        "Source Station": r"Source Station:\s*([\w\s]+)",
        "Destination Station": r"Destination Station:\s*([\w\s]+)",
        "Class Value": r"Class Value:\s*([\w\s]+)",
        "Fare Value": r"Fare Value:\s*(\d+)",
        "Adult/Child Value": r"Adult/Child Value:\s*(Adult:\s*\d+,\s*Child:\s*\d+)",
        "Return Details": r"Return Details:\s*([\w\s]+)",
        "Return From": r"Return From:\s*([\w\s]+)",
        "Return To": r"Return To:\s*([\w\s]+)",
        "Validity": r"Validity:\s*([\w\s]+)",
        "Timestamp": r"Timestamp:\s*([\d:]+)",
        "Value": r"Value:\s*(\w+)"
    }
    #Extract the data based on pattern matching done above
    for key, pattern in patterns.items():
        match = re.search(pattern, text)
        if match:
            info[key] = match.group(1)

    return info
#Function call to print extracted info
ticket_info = extract_ticket_info(text)
print(ticket_info)

def clean_ticket_info(ticket_info):
    cleaned_info = {}

    for key, value in ticket_info.items():
        # We remove the new lines and extra text from values by splitting and keeping only first part
        cleaned_value = value.split('\n')[0].strip()
        #for removing certain fields that contain new line text
        if key == "Source Station" and "Destination" in cleaned_value:
            cleaned_value = cleaned_value.split('Destination')[0].strip()
        if key == "Destination Station" and "Class" in cleaned_value:
            cleaned_value = cleaned_value.split('Class')[0].strip()
        if key == "Class Value" and "Fare" in cleaned_value:
            cleaned_value = cleaned_value.split('Fare')[0].strip()
        if key == "Return Details" and "Return From" in cleaned_value:
            cleaned_value = cleaned_value.split('Return From')[0].strip()
        if key == "Return From" and "Return To" in cleaned_value:
            cleaned_value = cleaned_value.split('Return To')[0].strip()
        if key == "Return To" and "Validity" in cleaned_value:
            cleaned_value = cleaned_value.split('Validity')[0].strip()
        if key == "Validity" and "Mid Night Of" in cleaned_value:
            cleaned_value = value.strip()

        cleaned_info[key] = cleaned_value

    return cleaned_info
#Cleaned ticket info
cleaned_ticket_info = clean_ticket_info(ticket_info)
print(cleaned_ticket_info)

import csv

# Save the extracted information
def save_to_csv(data, filename="ticket_info.csv"):
    with open(filename, mode="w", newline="") as file:
        writer = csv.writer(file)
        writer.writerow(["Field", "Value"])
        for key, value in data.items():
            writer.writerow([key, value])  #Writes each key-value pairs

#Calls the function to save data
filename = "ticket_info.csv"
save_to_csv(ticket_info)
print(f"Data saved to {filename}")

from datetime import datetime, timedelta


def display_ticket_info(ticket_info):#Displays key details of ticket
    print("=== Ticket Information ===")
    print(f"Source Station: {ticket_info['Source Station']}")
    print(f"Destination Station: {ticket_info['Destination Station']}")
    print(f"Journey Type: {ticket_info['Journey Type']}")
    print(f"Adult/Child: {ticket_info['Adult/Child Value']}")
    print(f"Class: {ticket_info['Class Value']}")
    print(f"Fare: {ticket_info['Fare Value']}")
    print("==========================")

def validate_ticket_time(ticket_info):
    current_time_str = input("Enter current time (hh:mm, 24-hour format): ")
    #Asks for current time from ticket checker
    try:
        #Convert timestamp to date time object
        ticket_time_str = ticket_info['Timestamp']
        ticket_time = datetime.strptime(ticket_time_str, "%H:%M")
        #Converts current from tc to datetime object
        current_time = datetime.strptime(current_time_str, "%H:%M")
        #Checks time diff calc
        time_difference = current_time - ticket_time

        # One-hour window check
        if timedelta(0) <= time_difference <= timedelta(hours=1):
            return "Ticket is Valid: Time is within the one-hour window"
        else:
            return "Invalid Ticket: Time is outside the one-hour window"
    except ValueError as e:
        return f"Error parsing time: {str(e)}"


# Display the ticket information
display_ticket_info(ticket_info)

# Validate the ticket time
validation_result = validate_ticket_time(ticket_info)
print(validation_result)

import pandas as pd

# Load the dataset
dataset_path = "/content/Mumbai Local Train Dataset.csv"

try:
    train_data = pd.read_csv(dataset_path)
    print("Dataset loaded successfully.")
except Exception as e:
    print(f"Error loading dataset: {e}")
#Convert all station names to uppercase to reduce error
train_data_upper = train_data.applymap(lambda s: s.upper() if isinstance(s, str) else s)

#To check if station input given by ticket checker is in dataset or not
def validate_station(station_name, train_data):
    #Convert input name to uppercase for matching
    station_name = station_name.strip().upper()

    #Flattens 2D to 1D array only unique values are allowed check only str type
    unique_stations = pd.unique(train_data_upper.values.ravel('K'))
    unique_stations = [s for s in unique_stations if isinstance(s, str)]


    #checks for station
    if station_name in unique_stations:
        return f"'{station_name}' is a valid station in the dataset."
    else:
        return f"'{station_name}' is NOT found in the dataset."



#Prompts user for input
user_station = input("Enter the station name you want to validate: ")

#Function call
validation_result = validate_station(user_station, train_data)
print(validation_result)

def is_station_between(commuter_station, source_station, destination_station, train_data):
    #all inputs  to uppercase
    commuter_station = commuter_station.strip().upper()
    source_station = source_station.strip().upper()
    destination_station = destination_station.strip().upper()
    train_data_upper = train_data['STATION'].str.upper()

    #Get the indices of source and destination stations
    try:
        source_index = train_data_upper[train_data_upper == source_station].index[0]
        destination_index = train_data_upper[train_data_upper == destination_station].index[0]
    except IndexError:
        return "Source or destination station not found in the dataset."

    #Check order sourcestn should always come before dest station
    if source_index > destination_index:
        source_index, destination_index = destination_index, source_index
    #Check if commuter is between source and destination
    if commuter_station in train_data_upper[source_index:destination_index + 1].values:
        return f"'{commuter_station}' is between '{source_station}' and '{destination_station}'."
    else:
        print("COMMUTER IS NOT TRAVELLING BETWEEN DESIGNATED STATIONS")
        return f"'{commuter_station}' is NOT between '{source_station}' and '{destination_station}'."
#DEMO
source_station = cleaned_ticket_info['Source Station']
destination_station = cleaned_ticket_info['Destination Station']
commuter_station = input("Enter commuter's station: ")

#Validates
result = is_station_between(commuter_station, source_station, destination_station, train_data)
print(result)